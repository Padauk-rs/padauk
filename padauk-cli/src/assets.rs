use anyhow::Context;
use std::collections::BTreeMap;
use std::fs;
use std::path::Path;
use walkdir::WalkDir;

pub fn sync_and_generate_assets() -> anyhow::Result<()> {
    let project_root = std::env::current_dir().unwrap();
    let assets_src = project_root.join("assets");
    let android_res_base = project_root.join("android/app/src/main/res");
    let rust_src_dir = project_root.join("rust/src");
    let generated_file = rust_src_dir.join("generated/assets.rs");

    if !assets_src.exists() {
        println!("‚ÑπÔ∏è No assets/ folder found. Skipping asset generation.");
        return Ok(());
    }

    // Ensure base directories exist
    let drawable_dir = android_res_base.join("drawable");
    let raw_dir = android_res_base.join("raw");
    fs::create_dir_all(&drawable_dir)?;
    fs::create_dir_all(&raw_dir)?;

    // We use a tree structure to organize the nested modules
    let mut root_module = AssetModule::default();

    println!("üé® Syncing assets...");

    // Extensions allowed for drawable (images)
    let image_exts = ["png", "jpg", "jpeg", "webp", "gif", "xml", "svg"];
    // Extensions typically used in raw (can be broader, but filtering keeps it clean)
    // let raw_exts = [
    //     "json", "txt", "mp4", "mp3", "wav", "pdf", "html", "css", "js", "bin",
    // ];

    for entry in WalkDir::new(&assets_src).into_iter().filter_map(|e| e.ok()) {
        let path = entry.path();

        if path.is_file() {
            // Check extension
            let ext_str = path
                .extension()
                .and_then(|s| s.to_str())
                .unwrap_or("")
                .to_lowercase();
            if ext_str.is_empty() {
                continue;
            }

            // 1. Get relative path parts (e.g., ["image", "home.png"])
            let relative_path = match path.strip_prefix(&assets_src) {
                Ok(p) => p,
                Err(_) => continue,
            };

            // 2. Identify top-level folder to determine destination
            let mut components_iter = relative_path.components();
            let top_folder = match components_iter.next() {
                Some(c) => c.as_os_str().to_str().unwrap_or(""),
                None => continue, // Root file in assets/, skip or handle differently
            };

            let (target_res_dir, sub_path, is_valid_ext) = match top_folder {
                "image" => (
                    &drawable_dir,
                    relative_path.strip_prefix("image")?,
                    image_exts.contains(&ext_str.as_str()),
                ),
                "raw" => (
                    &raw_dir,
                    relative_path.strip_prefix("raw")?,
                    true, //raw_exts.contains(&ext_str.as_str()),
                ),
                _ => continue, // Skip other folders for now
            };

            if !is_valid_ext {
                continue;
            }

            // 3. Generate the flat Resource ID based on SUB-PATH (stripping top folder)
            // assets/image/sub/icon.png -> sub_icon (for R.drawable.sub_icon)
            let resource_id = generate_flat_resource_id(sub_path);

            // 4. Copy to Android
            let dest_filename = format!("{}.{}", resource_id, ext_str);
            let dest_path = target_res_dir.join(&dest_filename);

            fs::copy(path, &dest_path)
                .with_context(|| format!("Failed to copy asset: {:?}", path))?;

            // 5. Insert into our Tree Structure for Rust generation
            // We use the FULL relative path components to maintain structure in Rust
            // e.g. assets::image::sub::ICON
            let components: Vec<&str> = relative_path
                .components()
                .filter_map(|c| c.as_os_str().to_str())
                .collect();

            if let Some((filename, folders)) = components.split_last() {
                // Constant name based ONLY on filename (e.g. "home.png" -> "HOME")
                let const_name = sanitize_const_name(filename);
                // The value of the constant is the resource_id (without "image_" prefix if it was in image folder)
                root_module.insert(folders, const_name, resource_id);
            }
        }
    }

    // 6. Generate the nested Rust code
    let mut rust_code = String::new();
    rust_code.push_str("// ‚ö°Ô∏è Auto-generated by Padauk. Do not edit manually.\n");
    rust_code.push_str("#[allow(dead_code)]\n");
    rust_code.push_str(&root_module.generate_code(0));

    fs::write(&generated_file, rust_code)?;
    println!("‚úÖ Generated assets.rs with nested structure");

    Ok(())
}

// --- Tree Structure for Code Generation ---

#[derive(Default)]
struct AssetModule {
    // Sorted map to ensure deterministic output
    sub_modules: BTreeMap<String, AssetModule>,
    constants: Vec<(String, String)>, // (CONST_NAME, resource_id)
}

impl AssetModule {
    fn insert(&mut self, folders: &[&str], const_name: String, resource_id: String) {
        if folders.is_empty() {
            self.constants.push((const_name, resource_id));
            return;
        }

        let module_name = sanitize_module_name(folders[0]);
        let entry = self.sub_modules.entry(module_name).or_default();
        entry.insert(&folders[1..], const_name, resource_id);
    }

    fn generate_code(&self, indent_level: usize) -> String {
        let mut code = String::new();
        let indent = "    ".repeat(indent_level);

        for (name, val) in &self.constants {
            code.push_str(&format!(
                "{}pub const {}: &str = \"{}\";\n",
                indent, name, val
            ));
        }

        // Add a newline between constants and modules if both exist
        if !self.constants.is_empty() && !self.sub_modules.is_empty() {
            code.push('\n');
        }

        for (mod_name, sub_mod) in &self.sub_modules {
            code.push_str(&format!("{}pub mod {} {{\n", indent, mod_name));
            code.push_str(&sub_mod.generate_code(indent_level + 1));
            code.push_str(&format!("{}}}\n", indent));
        }
        code
    }
}

// --- Sanitization Helpers ---

fn generate_flat_resource_id(relative_path: &Path) -> String {
    let components: Vec<&str> = relative_path
        .components()
        .filter_map(|c| c.as_os_str().to_str())
        .map(|s| {
            if let Some(idx) = s.rfind('.') {
                &s[0..idx]
            } else {
                s
            }
        })
        .collect();

    let raw_name = components.join("_");
    sanitize_android_id(&raw_name)
}

fn sanitize_const_name(filename: &str) -> String {
    let stem = if let Some(idx) = filename.rfind('.') {
        &filename[0..idx]
    } else {
        filename
    };

    let mut name = stem
        .to_uppercase()
        .replace(|c: char| !c.is_alphanumeric(), "_");

    // Ensure it starts with a letter if strictly numeric (unlikely for UPPERCASE but safe)
    if let Some(first) = name.chars().next() {
        if !first.is_alphabetic() && first != '_' {
            name = format!("_{}", name);
        }
    }
    name
}

fn sanitize_module_name(folder: &str) -> String {
    let mut name = folder
        .to_lowercase()
        .replace(|c: char| !c.is_alphanumeric(), "_");
    // Rust modules cannot be keywords (like 'crate', 'mod', 'pub') or start with numbers
    if let Some(first) = name.chars().next() {
        if !first.is_alphabetic() && first != '_' {
            name = format!("mod_{}", name);
        }
    }
    // Handle simple keyword conflicts if necessary
    if name == "struct" || name == "enum" || name == "mod" || name == "crate" {
        name = format!("{}_mod", name);
    }
    name
}

fn sanitize_android_id(raw: &str) -> String {
    let mut id = raw
        .to_lowercase()
        .replace(|c: char| !c.is_alphanumeric(), "_");

    if let Some(first) = id.chars().next() {
        if !first.is_alphabetic() {
            id = format!("img_{}", id);
        }
    }

    while id.contains("__") {
        id = id.replace("__", "_");
    }
    id.trim_matches('_').to_string()
}
